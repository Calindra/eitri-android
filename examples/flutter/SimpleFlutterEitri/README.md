# SimpleFlutterEitri

A comprehensive example demonstrating how to integrate Eitri framework into a Flutter application with native Android and iOS implementations. This project serves as a reference implementation for developers looking to embed Eitri apps within their existing Flutter applications.

## Project Overview

SimpleFlutterEitri is a Flutter application that showcases the integration of the Eitri framework across multiple platforms. The application features a single button that launches the "eitri-doctor" app through native platform channels, which is a diagnostic tool provided by the Eitri framework to validate and troubleshoot Eitri setups.

### Key Components

#### Flutter Layer
- **main.dart**: Flutter UI with platform channel integration for Eitri communication
- **MyHomePage**: Main Flutter widget containing the Eitri launch button

#### Android Native Layer
- **MainActivity**: Flutter activity with method channel handling for Android Eitri integration
- **MainApplication**: Application class handling Eitri framework initialization
- **EitriService**: Core service managing EitriMachine configuration and lifecycle
- **EitriBridgeHelper**: Utility class for exposing native APIs to Eitri apps
- **MainAppService**: Singleton service managing the EitriService instance

#### iOS Native Layer
- **AppDelegate**: iOS app delegate with Eitri framework initialization
- **EitriService**: Core service managing EitriMachine configuration and lifecycle (iOS)
- **EitriBridgeHelper**: Utility class for exposing native APIs to Eitri apps (iOS)

### Setup Instructions

1. Clone this repository
2. Open the project in your preferred Flutter IDE (VS Code, Android Studio, etc.)
3. Run `flutter pub get` to install dependencies
4. For Android: Open `android/` folder in Android Studio if needed
5. For iOS: Open `ios/Runner.xcworkspace` in Xcode if needed
6. Run `flutter run` to build and launch the application

## Post Install & Integration Guide

After successfully integrating the eitri-flutter SDK into your project, you may want to consider implementing additional features to enhance your app's capabilities.

The following sections outline optional integrations and features that can be implemented based on your specific requirements.

### Environment Key Management for Different Build Types

Environment keys for production and non-production environments will be provided separately. Builds must select the appropriate key when invoking the Eitri machine configuration:

#### Android Configuration

Configure in `android/app/src/main/kotlin/.../eitri/EitriService.kt:21`

#### iOS Configuration  

Configure in `ios/Runner/eitri/EitriService.swift:20`

### Development Environment Integration for Eitri Apps

For development builds only, implement an integrated development environment that allows developers to test their Eitri apps directly within the Flutter application:

#### Development Button Implementation

Add a dedicated Eitri development button in Flutter that provides two alternatives:

1. **Manual Workspace Input**: Allow developers to input a workspace ID manually
2. **QR Code Scanner**: Scan QR codes generated by the Eitri CLI

```dart
// Flutter implementation example
class DevelopmentWidget extends StatelessWidget {
  Future<void> _openWorkspace(String workspaceId) async {
    const channel = MethodChannel('tech.eitri/native_bridge');
    
    try {
      await channel.invokeMethod('openWorkspace', {
        'workspaceId': workspaceId, // e.g., "4321-4321-4321-4321-4312"
      });
    } on PlatformException catch (e) {
      print('Failed to open workspace: ${e.message}');
    }
  }

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: () => _showDevelopmentOptions(context),
      child: Text('Eitri Development'),
    );
  }

  void _showDevelopmentOptions(BuildContext context) {
    // Show dialog with input field or QR scanner
  }
}
```

#### Native Android Method Channel Handler
```kotlin
// In Application or MainActivity.kt
"openWorkspace" -> {
    val workspaceId = call.argument<String>("workspaceId")
    MainAppService.getInstance().eitriService.runOnTop(
        RunInput(workspaceId = workspaceId, context = this)
    )
    result.success(null)
}
```

#### Native iOS Method Channel Handler
```swift
// In iOS AppDelegate or FlutterViewController
case "openWorkspace":
    if let workspaceId = call.arguments as? String {
        EitriService.shared.runOnTop(RunInput(
            workspaceId: workspaceId,
            navControllerToPush: navigationController
        ))
        result(nil)
    }
```

#### Integration Benefits

Once captured and interpreted, a workspace ID can be used with the Eitri machine run command, opening the developer's workspace within the app and providing access to exclusive exposed app APIs.

### Exposed APIs for Enhanced Eitri App Context

Both Android and iOS implementations include `EitriBridgeHelper` classes that contain illustrative methods for exposing native capabilities to Eitri apps, allowing them to extend their functionality beyond their traditional sandbox:

#### Android Bridge Example
```kotlin
// Example from EitriBridgeHelper.kt
fun exposeFunctions(eitriMachine: EitriMachine, eitriMachineStack: EitriMachineStack) {
    // Simple math API example
    eitriMachine.bridge.exposeMethod("math", "sum") {
        val params = it.data
        params.getDouble("a") + params.getDouble("b")
    }
    
    // Additional APIs can be exposed here
    // Examples: session data sharing, device capabilities, etc.
}
```

#### iOS Bridge Example
```swift
// Example from EitriBridgeHelper.swift
func exposeFunctions(eitriMachine: EitriMachine) {
    // Simple math API example
    try? eitriMachine.bridge.exposeMethod(namespace: "math", methodName: "sum", fn: { params in
        if let a = params.data["a"] as? Double, let b = params.data["b"] as? Double {
            return a + b
        }
        throw NSError(domain: "math.sum.failed", code: 0)
    })
    
    // Additional APIs can be exposed here
    // Examples: session data sharing, device capabilities, etc.
}
```

#### Common Use Cases

- **Session Data Sharing**: Share client session information with Eitri apps
- **Device Capabilities**: Expose camera or other device features
- **Data Persistence**: Allow Eitri apps to store data in the native app's database
- **Flutter State Management**: Bridge Flutter state with Eitri apps

### Complete CLI Integration

The Eitri CLI generates QR codes and launches deeplinks following the pattern `eitri://workspace/${workspaceId}`. The CLI can also be configured to generate deeplinks using the app's specific protocol:

```
Configuration example: yourapp://workspace/${workspaceId}
```

This system enables the app to:
- Respond to deeplinks generated by the CLI
- Scan deeplinks using the device's standard camera
- Automatically launch appropriate Eitri apps based on the workspace ID

### Deeplink Integration

Implement deeplink handling to interpret links that reach flows created with Eitri apps:

#### Individual Deeplink Handling

You can create deeplink handlers to open dedicated eitri-apps using eitri-machine run method.

#### Dedicated Protocol for Eitri Apps

You can also implement a dedicated protocol for opening Eitri apps. Eg:

```
${yourapp}://run/${slug}/?${paramsInQueryString}
```

Example: `yourapp://run/customer-support/?userId=123&sessionId=abc`

The app can interpret these deeplinks and construct the run command dynamically, passing all values as parameters to the Eitri machine through the Flutter method channel.

#### Flutter Deeplink Handling
```dart
// Flutter deeplink handling example
class DeeplinkHandler {
  static const _channel = MethodChannel('tech.eitri/native_bridge');
  
  static Future<void> handleDeeplink(String deeplink) async {
    final uri = Uri.parse(deeplink);
    
    if (uri.scheme == 'yourapp' && uri.pathSegments.first == 'run') {
      final slug = uri.pathSegments[1];
      final params = uri.queryParameters;
      
      try {
        await _channel.invokeMethod('runEitriApp', {
          'slug': slug,
          'params': params,
        });
      } on PlatformException catch (e) {
        print('Failed to handle deeplink: ${e.message}');
      }
    }
  }
}
```

### Push Notification Integration

Push notification integration should preferably reuse the protocols created for deeplink integration. This approach ensures consistency and reduces complexity:

```dart
// Flutter push notification payload example
{
  "type": "eitri_launch",
  "deeplink": "yourapp://run/notification-handler/?notificationId=456&type=urgent"
}
```

When a push notification is received, extract the deeplink and process it using the same deeplink handling mechanism implemented for direct deeplink integration.

## Development Notes

### Configuration Points

- **Android Debug Mode**: Configure `isEitriDevEnabled()` based on build type (EitriService.kt:71-74)
- **iOS Debug Mode**: Configure `isEitriDevEnabled()` based on build type (EitriService.swift:68-71)
- **Flutter Method Channel**: Uses `tech.eitri/native_bridge` for platform communication

### Platform-Specific Implementation Details

#### Android
- Uses Kotlin for native Android implementation
- Integrates with Flutter through MethodChannel in MainApplication or MainActivity
- EitriService manages machine lifecycle with coroutines

#### iOS  
- Uses Swift for native iOS implementation
- Integrates with Flutter through MethodChannel in AppDelegate
- EitriService manages machine lifecycle with async/await

#### Flutter
- Uses MethodChannel for bidirectional communication with native platforms
- Maintains consistent API across both platforms

## Security Considerations

- Debug mode should be disabled in production builds on both platforms
- Deeplink handling should include proper validation and sanitization
- Preferably, workspace running and eitri-app development should only be done in development builds
